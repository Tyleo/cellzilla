<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">

        <title>cellzilla</title>

        <meta name="description" content="Describes a method for simulating cells for a final class project.">
        <meta name="author" content="Lisa Lau and Tyler Wolf Leonhardt">

        <style type="text/css">
            body {
                font-family: Arial;
            }
            .title {
                font-size: 2.5em;
            }
            .subtitle {
                font-size: 1em;
                color: rgb(90, 90, 90);
            }
            .heading1 {
                font-size: 1.5em;
                color: rgb(46, 116, 181);
            }
            .heading2 {
                font-size: 1.3em;
                color: rgb(46, 116, 181);
            }
            .heading3 {
                font-size: 1.1em;
                color: rgb(31, 77, 120);
            }
            .paragraph {
                text-indent: 3em;
                font-size: 1em;
            }
            .normalText {
                font-size: 1em;
            }
            .centered {
                width: 50em;
                margin: 0 auto;
            }
        </style>
    </head>

    <body>
        <div class="centered">
            <div class="title">Cell Simulations with the Marching Cubes Algorithm</div>
            <div class="subtitle">By Lisa Lau and Tyler Wolf Leonhardt</div>
            <br/>
            <div class="heading1">1 - Abstract</div>
            <div class="paragraph">
                The marching cubes algorithm is an algorithm which allows a mesh to be created from a scalar field <a href="http://en.wikipedia.org/wiki/Marching_cubes">[1]</a>. In other words, the algorithm takes a 3-dimensional array of points with certain intensities and creates a mesh which represent a volume of neighbor points above a certain intensity threshold. This algorithm can be used to create many different types of procedurally generated meshes. One of the procedurally generated meshes that this algorithm can create is called a meatball. Metaballs are spherical objects which modify the geometry of other metaballs, sometimes even to the point of fusing, when they are close to each other <a href="http://en.wikipedia.org/wiki/Metaballs">[2]</a>. The geometry created by two metaballs traveling away from each other is roughly similar to that of a cell during mitosis. In the following report we provide information about our implementation of the marching cubes algorithm and describe how we used it to generate a cell-mitosis animation.
            </div>
            <br/>
            <div class="heading1">2 - The Algorithm</div>
            <div class="paragraph">
                On its own the marching cubes algorithm requires a large amount of code. The implementation of the cell-mitosis was originally implemented using open-source code found online <a href="http://wiki.unity3d.com/index.php?title=MetaBalls">[3]</a>. This algorithm was much too slow for our use and had to be completely rewritten. For simplicity we divided the algorithm across a collection of classes. Classes of importance are described in the subsection, below and the computation itself is described in the following subsection.
            </div>
            <br/>
            <div class="heading2">2.1 - Classes</div>
            <div class="heading3">2.1.1 - MarchingCubesEnvironment</div>
            <div class="paragraph">
                The environment which the generated mesh can live in. This class allows the number of cubes in the environment to be specified along each axis. Increasing the number of cubes increases the quality of the mesh but the mesh also takes longer to generate. If part of the mesh leaves the bounds specified by the environment it will no longer be visible. After the environment is created, the cubes within it can be indexed as though they were members of an array.
            </div>
            <br/>
            <div class="heading3">2.1.2 - MarchingEntity</div>
            <div class="paragraph">
                An entity within the environment. This entity gives the points in the environment their intensities. Each entity can generate intensities however it wishes.
            </div>
            <br/>
            <div class="heading3">2.1.2 - MarchingMetaball</div>
            <div class="paragraph">
                A marching entity which generates intensities using the following equation:
            </div>
            <br/>
            <div align="center"><img src="Equation 1.png" width="623em" height="76em" /></div>
            <br/>
            <div class="paragraph">
                The square magnitude was used so that a square root did not have to be taken for every point. This computation would have been prohibitively expensive. Additionally, the elimination of the floating point division would also have provided a much more computationally efficient equation.
            </div>
            <br/>
            <div class="heading3">2.1.4 - MarchingCube</div>
            <div class="paragraph">
                A cube within the environment with local space coordinates between -0.5 and +0.5 in each direction (X, Y, Z). It consists of 8 points and 12 edges.
            </div>
            <br/>
            <div class="heading3">2.1.5 - MarchingEdge</div>
            <div class="paragraph">
                An edge within the environment. It consists of 2 points.
            </div>
            <br/>
            <div class="heading3">2.1.6 - MarchingPoint</div>
            <div class="paragraph">
                A point within the environment.
            </div>
            <br/>
            <div class="heading3">2.1.7 - EdgeIndex</div>
            <div class="paragraph">
                The 0-11 index of an edge in a marching cube.
            </div>
            <br/>
            <div class="heading3">2.1.8 - PointIndex</div>
            <div class="paragraph">
                The 0-7 index of a point in a marching cube.
            </div>
            <br/>
            <div class="heading3">2.1.9 - EdgeFlags</div>
            <div class="paragraph">
                Flags indicating which edges will contain a vertex if the cube were drawn.
            </div>
            <br/>
            <div class="heading3">2.1.10 - PointFlags</div>
            <div class="paragraph">
                Flags indicating which points have an intensity above the threshold. These flags are all adjacent numbers within the range 0-255 so they can be used to index an array.
            </div>
            <br/>
            <div class="heading3">2.1.11 - PointFlagsToEdgeConverter</div>
            <div class="paragraph">
                Converts point flags to edge flags or to a list of edge indices using tables generated from a utility.
            </div>
            <br/>
            <div class="heading2">2.2 - Computation</div>
            <div class="paragraph">
                The following procedure describes this particular implementation of the algorithm:
            </div>
            <br/>
            <ol>
                <li>Get the set of entities which we wish to create a mesh for.</li>
                <li>Remove one entity from the set and determine where its centroid is located in the local-space of the marching cubes environment.</li>
                <li>Convert the local-space coordinates to an index into the cube-lattice. Clamp the coordinates if the entity is outside of the bounds.</li>
                <li>Search all cubes starting from our index along the Z-axis towards the closest edge of the environment applying intensities to their points as we go, stop when we find a cube at the surface of the mesh, the edge of the environment, or a cube that has already been searched.</li>
                <li>If we found a new cube at the surface of the mesh search all of the neighboring cubes and repeat this step.</li>
            </ol>
            <div class="paragraph">
                The following procedure describes how a cube is searched:
            </div>
            <br/>
            <ol>
                <li>Calculate the intensity at each point in the cube.</li>
                <li>Obtain a set of point flags indicating which points are on.</li>
                <li>Obtain a set of edge flags from the point flags using the point flags to edge converter.</li>
                <li>Interpolate new points along each of these edges using their constituent points and the point intensities and assign an index to each edge. Essentially linearly interpolate the two points and use the result of the following equation as the interpolant:</li>
                <br/>
                <div align="center"><img src="Equation 2.png" width="575em" height="69em" /></div>
                <br/>
                <li>Add the new interpolated points to a list of vertexes we will draw.</li>
                <li>Calculate the normal of each of the edges we just added using the following equation:</li>
                <br/>
                <div align="center"><img src="Equation 3.png" width="575em" height="167em" /></div>
                <br/>
                <li>Add the new normal to a list of the normal of each vertex we will draw. They should be added in the same order that the vertices were added in.</li>
                <li>Obtain a set of indices from the point flags indicating the edges of the cube which will be used as triangles. Index the cube for these edges and add their indices to a list of triangle indices.</li>
            </ol>
            <div class="paragraph">
                After all of the cubes are searched and the lists of vertices, normal and triangle indices are built the new mesh can be generated.
            </div>
            <br/>
            <div class="heading2">2.3 - Results</div>
            <div class="heading3">2.3.1 - Overall Simulation</div>
            <div class="paragraph">
                For the overall simulation 11 marching cubes environments were created and 8 metaballs were added to each environment. Each environment contained 15 cubes in each direction totaling 3,375 cells each or 37,125 total cells. The meshes of each environment were textured with a transparent texture and shaded with a transparent diffuse shader. The metaballs were clustered in groups of two within their environment so that they could be easily controlled. Two sets of the metaballs could be controlled using the up and down arrow keys on a standard keyboard: the up key would bring the balls apart and the down key would bring them together. The rest of the balls were controlled automatically using scripts. A skybox, light, music and particle effects were also provided for atmosphere. The simulation ran with an average framerate around 30 FPS on a test laptop. Figure 1, below, provides an example of what the scene looked like.
            </div>
            <br/>
            <table align="center">
                <tr>
                    <td align="center">
                        <img src="Figure 1.png" width="300em" height="300em">
                    </td>
                </tr>
                <tr>
                    <td align="center">
                        <div class="normalText">
                            <b>Figure 1</b>: Overall Simulation
                        </div>
                    </td>
                </tr>
            </table>
            <br/>
            <div class="paragraph">
                Figure 2, below provides an example of the vertices used to create the central cell.
            </div>
            <br/>
            <table align="center">
                <tr>
                    <td align="center">
                        <img src="Figure 2.png" width="300em" height="300em">
                    </td>
                </tr>
                <tr>
                    <td align="center">
                        <div class="normalText">
                            <b>Figure 2</b>: Overall Central Cell Mesh
                        </div>
                    </td>
                </tr>
            </table>
            <br/>
            <div class="heading3">2.3.2 - Single Cell</div>
            <div class="paragraph">
                For the single-cell simulation 1 marching cubes environments was created and 8 metaballs were added to the environment. The environment contained 60 cubes in each direction totaling 216,000 cells. The meshes of the environment were textured with a transparent texture and shaded with a transparent diffuse shader. The metaballs were clustered in two group within the environment so that they could be easily controlled. The two sets of the metaballs could be controlled using the up and down arrow keys on a standard keyboard: the up key would bring the balls apart and the down key would bring them together. A skybox, light, music and particle effects were also provided for atmosphere. The simulation ran with an average framerate around 30 FPS on a test laptop. Figure 3, below, provides an example of what the scene looked like.
            </div>
            <br/>
            <table align="center">
                <tr>
                    <td align="center">
                        <img src="Figure 3.png" width="300em" height="300em">
                    </td>
                </tr>
                <tr>
                    <td align="center">
                        <div class="normalText">
                            <b>Figure 3</b>: Single Cell Simulation
                        </div>
                    </td>
                </tr>
            </table>
            <br/>
            <div class="paragraph">
                Figure 4, below provides an example of the vertices used to create the cell.
            </div>
            <br/>
            <table align="center">
                <tr>
                    <td align="center">
                        <img src="Figure 4.png" width="300em" height="300em">
                    </td>
                </tr>
                <tr>
                    <td align="center">
                        <div class="normalText">
                            <b>Figure 4</b>: Single Cell Mesh
                        </div>
                    </td>
                </tr>
            </table>
            <br/>
            <div class="heading1">3 - References</div>
            <div class="paragraph">
                [1] <a href="http://en.wikipedia.org/wiki/Marching_cubes">http://en.wikipedia.org/wiki/Marching_cubes</a>
            </div>
            <div class="paragraph">
                [2] <a href="http://en.wikipedia.org/wiki/Metaballs">http://en.wikipedia.org/wiki/Metaballs</a>
            </div>
            <div class="paragraph">
                [3] <a href="http://wiki.unity3d.com/index.php?title=MetaBalls">http://wiki.unity3d.com/index.php?title=MetaBalls</a>
            </div>
            <br/>
            <div class="heading1">4 - Additional Resources</div>
            <div class="paragraph">
                The source code described within this document is available at <a href="https://github.com/Tyleo/cellzilla">https://github.com/Tyleo/cellzilla</a>.
            </div>
            <br/>
            <div class="paragraph">
                The application described within this document can be run using Unity Web Player at <a href="http://tyleo.github.io/cellzilla/app/cellzilla-single.html">http://tyleo.github.io/cellzilla/app/cellzilla-single.html</a>. This simulation demonstrates a single cell with 60 cubes along each row.
            </div>
            <br/>
            <div class="paragraph">
                A video of the application running is available at <a href="http://tyleo.github.io/cellzilla/video/video.html">http://tyleo.github.io/cellzilla/video/video.html</a>
            </div>
            <br/>
            <br/>
        </div>
    </body>
</html>
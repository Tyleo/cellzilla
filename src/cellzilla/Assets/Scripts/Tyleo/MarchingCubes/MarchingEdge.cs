using System.Collections.Generic;
using System.Text;
using UnityEngine;

namespace Tyleo.MarchingCubes
{
    /// <summary>
    /// An edge in a MarchingCube.
    /// </summary>
    public sealed class MarchingEdge
    {
        private readonly MarchingPoint _marchingPoint0;
        private readonly MarchingPoint _marchingPoint1;
        private uint _lastFrameTouched = 0;
        private Vector3 _localSpaceCoordinates = Vector3.zero;
        private Vector3 _worldSpaceCoordinates = Vector3.zero;
        private Vector3 _edgeNormal = Vector3.zero;
        private int _edgeIndex = 0;

        /// <summary>
        /// A MarchingPoint on the side of the MarchingEdge opposite MarchingPoint1.
        /// </summary>
        public MarchingPoint MarchingPoint0 { get { return _marchingPoint0; } }
        /// <summary>
        /// A MarchingPoint on the side of the MarchingEdge opposite MarchingPoint0.
        /// </summary>
        public MarchingPoint MarchingPoint1 { get { return _marchingPoint1; } }

        /// <summary>
        /// The index of the last frame on which this cube was updated.
        /// </summary>
        public uint LastFrameTouched { get { return _lastFrameTouched; } }
        /// <summary>
        /// When considering this MarchingEdge as a vertex in a mesh, these coordinates are the
        /// local-space coordinates of the vertex.
        /// </summary>
        public Vector3 LocalSpaceCoordinates { get { return _localSpaceCoordinates; } }
        /// <summary>
        /// When considering this MarchingEdge as a vertex in a mesh, this vertex is the normal of
        /// the vertex in local-space.
        /// </summary>
        public Vector3 EdgeNormal { get { return _edgeNormal; } }
        /// <summary>
        /// When considering this MarchingEdge as a vertex in a mesh, this is the index which can be
        /// used to locate it within the mesh.
        /// </summary>
        public int VertexIndex { get { return _edgeIndex; } }

        /// <summary>
        /// Updates the edge using the marching cubes algorithm. This does not update the edge's
        /// points.
        /// </summary>
        /// <param name="currentFrameIndex">
        /// The index of the current frame.
        /// </param>
        /// <param name="marchingEntities">
        /// The entities used to update the MarchingEdge.
        /// </param>
        /// <param name="intensityThreshold">
        /// The intensity above which points can be considered outside of the mesh.
        /// </param>
        /// <param name="meshData">
        /// Data which will be updated if this edge is on the surface of the mesh being generated by
        /// the marching cubes algorithm.
        /// </param>
        public void ProcessEdge(uint currentFrameIndex, IEnumerable<MarchingEntity> marchingEntities, float intensityThreshold, MeshDataProvider meshData)
        {
            _lastFrameTouched = currentFrameIndex;
            _edgeIndex = meshData.GetCurrentEdgeIndex();
            SetLocalAndWorldSpaceCoordinates(intensityThreshold);
            _edgeNormal = GetEdgeNormal(marchingEntities);

            meshData.AddVertexAndNormal(_localSpaceCoordinates, _edgeNormal);
        }

        private void SetLocalAndWorldSpaceCoordinates(float intensityThreshold)
        {
            // We interpolate the two points which compose this mesh to find the new vertex for our
            // mesh.

            var interpolant = (intensityThreshold - _marchingPoint0.Intensity) / (_marchingPoint1.Intensity - _marchingPoint0.Intensity);

            _localSpaceCoordinates =
                Vector3.Lerp(
                    _marchingPoint0.LocalSpaceCoordinates,
                    _marchingPoint1.LocalSpaceCoordinates,
                    interpolant
                );

            _worldSpaceCoordinates =
                Vector3.Lerp(
                    _marchingPoint0.WorldSpaceCoordinates,
                    _marchingPoint1.WorldSpaceCoordinates,
                    interpolant
                );
        }

        private Vector3 GetEdgeNormal(IEnumerable<MarchingEntity> marchingEntities)
        {
            // We draw a vector from each marching entity to this edge's mesh vertex in local space.
            // After summing these vectors we normalize them to get the normal to this edge's mesh
            // vertex.
            var normal = Vector3.zero;
            foreach (var marchingEntity in marchingEntities)
            {
                var edgeToEntity = marchingEntity.EnvironmentSpaceCoordinates - _localSpaceCoordinates;
                normal += edgeToEntity * marchingEntity.GetIntensity(_worldSpaceCoordinates);
            }
            return normal.normalized;
        }

        /// <summary>
        /// Converts this edge to a string representation.
        /// </summary>
        /// <returns>
        /// A string representation of this edge.
        /// </returns>
        public override string ToString()
        {
            return
                new StringBuilder()
                .Append('{')
                .Append(_marchingPoint0)
                .Append(", ")
                .Append(_marchingPoint1)
                .Append('}')
                .ToString();
        }

        /// <summary>
        /// Creates a MarchingEdge from two MarchingPoints.
        /// </summary>
        /// <param name="marchingPoint0">
        /// A MarchingPoint on the side of the MarchingEdge opposite MarchingPoint1.
        /// </param>
        /// <param name="marchingPoint1">
        /// A MarchingPoint on the side of the MarchingEdge opposite MarchingPoint0.
        /// </param>
        public MarchingEdge(MarchingPoint marchingPoint0, MarchingPoint marchingPoint1)
        {
            _marchingPoint0 = marchingPoint0;
            _marchingPoint1 = marchingPoint1;
        }
    }
}
